%%%FILENAME%%: Standalone Stateflow Chart
%     %%FILENAME%%Object = %%FILENAME%%(NAME, VALUE) creates a Stateflow chart object.

%     NAME is character vector specifying a chart data object.
%     VALUE specifies the initial value for the chart data.

%     Examples
%         Create a Stateflow chart object:
%         %%FILENAME%%Object = %%FILENAME%%()

%     %%FILENAME%%% functions: 
%         step: Executes chart object using optional NAME-VALUE arguments to initialize chart data.
%         COIN: Calls event 'COIN' using optional NAME-VALUE arguments to initialize chart data.
%         COFFEE: Calls event 'COFFEE' using optional NAME-VALUE arguments to initialize chart data.
%         getActiveStates: Returns current active states.

%     %%FILENAME%%% public fields: 


%This file is automatically generated by Stateflow.




%__SFX_CLASS_START__
classdef SFlogic < handle


    properties (Access=public, Hidden=true, Constant=true)
        StateflowInternalConstData = struct(...
            'ChartName','SFlogic' ...
            ,'ModelSavedIn', struct('mlVersion','R2025a','sfVersion', '82500000')...
            ,'AllDataName',{{}} ...
            ,'AllDataId',{{}} ...
            ,'LocalDataName',{{}} ...
            ,'LocalDataId',{{}} ...
            ,'ConstantDataName',{{}} ...
            ,'ConstantDataId',{{}} ...
            ,'InputEventName',{{'COIN', 'COFFEE', 'TEA', 'CHOCO', 'GINSENG', 'TAKEN'}} ...
            ,'InputEventId',{{31, 41, 42, 43, 44, 47}} ...
            ,'UninitializedDataName',{{}} ...
            ,'UseRealTimeTemporal',true ...
            ,'ChartLink', '<a href="matlab:edit SFlogic.sfx">SFlogic</a>' ...
            ,'UninitializedDataLinks','' ...
            )
    end

    properties (Access=public, Hidden=true)
        StateflowInternalData
    end

    methods (Access=public)
        function this = SFlogic(varargin)
            coder.ignoreCatch()
            try %#ok<*EMTC>
                this.fInitializeChartData(varargin{:});
                this.reset();
                this.StateflowInternalData.SharedRuntime.parseArguments(this, true,  nargout, varargin{:});
            catch tOriginalException
                if isempty(this.StateflowInternalData)
                    this.reset();
                end
                tTranslatedException = this.StateflowInternalData.AnimationRuntime.runtimeException(tOriginalException);
                throw(tTranslatedException);
            end
            coder.ignoreCatch()
            try
                if this.StateflowInternalData.ConfigurationOptions.ExecuteInitStep
                    this.step;
                    this.StateflowInternalData.SharedRuntime.verifyForEmptyData(this);
                end
            catch tOriginalException
                if isvalid(this)
                    throw(tOriginalException);
                end
            end
        end

        function step(this, varargin)
            tTranslatedException_1 = [];
            coder.ignoreCatch()
            try
                coder.ignoreCatch();
                try
                    if this.StateflowInternalData.IsExecuting
                        this.StateflowInternalData.SharedRuntime.pushToEventQueue(this,'fStepImpl', varargin{:});
                        return;
                    end
                    this.StateflowInternalData.IsExecuting = true;
                    this.fStepImpl(varargin{:});
                    this.StateflowInternalData.SharedRuntime.processEventQueue(this);
                    this.StateflowInternalData.IsExecuting = false;
                catch tOriginalException
                    this.StateflowInternalData.IsExecuting = false;
                    tTranslatedException_1 = this.StateflowInternalData.AnimationRuntime.runtimeException(tOriginalException);
                end
                if isempty(tTranslatedException_1)
                    this; %#ok<VUNUS> 
                end
                if ~isempty(tTranslatedException_1)
                    throw(tTranslatedException_1);
                end
            catch tOriginalException_1
                if isvalid(this)
                    throw(tOriginalException_1);
                end
            end
        end

        function set(this, tInputArgument, tInputArgument_1)
            this.(tInputArgument)= tInputArgument_1;
        end

        function tReturnValue = get(this, tInputArgument)
            tReturnValue = this.(tInputArgument);
        end

        function COIN(this, varargin)
            try
                try
                    if this.StateflowInternalData.IsExecuting
                        this.StateflowInternalData.SharedRuntime.pushToEventQueue(this,'EventImpl_COIN', varargin{:});
                        return;
                    end
                    this.StateflowInternalData.IsExecuting = true;
                    this.EventImpl_COIN(varargin{:});
                    this.StateflowInternalData.SharedRuntime.processEventQueue(this);
                    this.StateflowInternalData.IsExecuting = false;
                catch tOriginalException
                    this.StateflowInternalData.IsExecuting = false;
                    throw(tOriginalException);
                end
            catch tOriginalException_1
                if isvalid(this)
                    throw(tOriginalException_1);
                end
            end
        end

        function COFFEE(this, varargin)
            try
                try
                    if this.StateflowInternalData.IsExecuting
                        this.StateflowInternalData.SharedRuntime.pushToEventQueue(this,'EventImpl_COFFEE', varargin{:});
                        return;
                    end
                    this.StateflowInternalData.IsExecuting = true;
                    this.EventImpl_COFFEE(varargin{:});
                    this.StateflowInternalData.SharedRuntime.processEventQueue(this);
                    this.StateflowInternalData.IsExecuting = false;
                catch tOriginalException
                    this.StateflowInternalData.IsExecuting = false;
                    throw(tOriginalException);
                end
            catch tOriginalException_1
                if isvalid(this)
                    throw(tOriginalException_1);
                end
            end
        end

        function TEA(this, varargin)
            try
                try
                    if this.StateflowInternalData.IsExecuting
                        this.StateflowInternalData.SharedRuntime.pushToEventQueue(this,'EventImpl_TEA', varargin{:});
                        return;
                    end
                    this.StateflowInternalData.IsExecuting = true;
                    this.EventImpl_TEA(varargin{:});
                    this.StateflowInternalData.SharedRuntime.processEventQueue(this);
                    this.StateflowInternalData.IsExecuting = false;
                catch tOriginalException
                    this.StateflowInternalData.IsExecuting = false;
                    throw(tOriginalException);
                end
            catch tOriginalException_1
                if isvalid(this)
                    throw(tOriginalException_1);
                end
            end
        end

        function CHOCO(this, varargin)
            try
                try
                    if this.StateflowInternalData.IsExecuting
                        this.StateflowInternalData.SharedRuntime.pushToEventQueue(this,'EventImpl_CHOCO', varargin{:});
                        return;
                    end
                    this.StateflowInternalData.IsExecuting = true;
                    this.EventImpl_CHOCO(varargin{:});
                    this.StateflowInternalData.SharedRuntime.processEventQueue(this);
                    this.StateflowInternalData.IsExecuting = false;
                catch tOriginalException
                    this.StateflowInternalData.IsExecuting = false;
                    throw(tOriginalException);
                end
            catch tOriginalException_1
                if isvalid(this)
                    throw(tOriginalException_1);
                end
            end
        end

        function GINSENG(this, varargin)
            try
                try
                    if this.StateflowInternalData.IsExecuting
                        this.StateflowInternalData.SharedRuntime.pushToEventQueue(this,'EventImpl_GINSENG', varargin{:});
                        return;
                    end
                    this.StateflowInternalData.IsExecuting = true;
                    this.EventImpl_GINSENG(varargin{:});
                    this.StateflowInternalData.SharedRuntime.processEventQueue(this);
                    this.StateflowInternalData.IsExecuting = false;
                catch tOriginalException
                    this.StateflowInternalData.IsExecuting = false;
                    throw(tOriginalException);
                end
            catch tOriginalException_1
                if isvalid(this)
                    throw(tOriginalException_1);
                end
            end
        end

        function TAKEN(this, varargin)
            try
                try
                    if this.StateflowInternalData.IsExecuting
                        this.StateflowInternalData.SharedRuntime.pushToEventQueue(this,'EventImpl_TAKEN', varargin{:});
                        return;
                    end
                    this.StateflowInternalData.IsExecuting = true;
                    this.EventImpl_TAKEN(varargin{:});
                    this.StateflowInternalData.SharedRuntime.processEventQueue(this);
                    this.StateflowInternalData.IsExecuting = false;
                catch tOriginalException
                    this.StateflowInternalData.IsExecuting = false;
                    throw(tOriginalException);
                end
            catch tOriginalException_1
                if isvalid(this)
                    throw(tOriginalException_1);
                end
            end
        end

        function disp(this)
            if ~isscalar(this)
                disp([class(this) ' of size [' num2str(size(this)) '].']);
                return;
            end
            this.StateflowInternalData.SharedRuntime.dispHelper(this, inputname(1));
        end

        function tFunctionLocalVariable = getActiveStates(this)
            tFunctionLocalVariable = cell(1,0);
            if this.StateflowInternalData.ActiveChildVars.ActiveChildVar_SFlogic == 27
                tFunctionLocalVariable{end+1} = "Idling";
            end
            if this.StateflowInternalData.ActiveChildVars.ActiveChildVar_SFlogic == 25
                tFunctionLocalVariable{end+1} = "Initialize";
            end
            if this.StateflowInternalData.ActiveChildVars.ActiveChildVar_SFlogic == 28
                tFunctionLocalVariable{end+1} = "Operate";
            end
            if this.StateflowInternalData.ActiveChildVars.ActiveChildVar_Operate == 34
                tFunctionLocalVariable{end+1} = "Operate.Preparation";
            end
            if this.StateflowInternalData.ActiveChildVars.ActiveChildVar_Operate == 33
                tFunctionLocalVariable{end+1} = "Operate.Selection";
            end
            if this.StateflowInternalData.ActiveChildVars.ActiveChildVar_Operate == 35
                tFunctionLocalVariable{end+1} = "Operate.Serving";
            end
        end

        function reset(this)
            this.StateflowInternalData = struct(...
                'SharedRuntime', Stateflow.internal.getRuntime('-runtimeType', 'SharedRuntime','-sfxObject', this)...
                ,'TimerRuntime', Stateflow.internal.getRuntime('-runtimeType', 'TimerRuntime', '-sfxObject', this)...
                ,'AnimationRuntime', Stateflow.internal.getRuntime('-runtimeType','AnimationRuntime','-sfxObject', this, '-explicitBlackBoxRuntimeSelection', true) ...
                ,'CurrentTime',0 ...
                ,'QueuedMethodNames',{{}}...
                ,'QueuedMethodArguments',{{}}...
                ,'IsExecuting',false...
                ,'ConfigurationOptions',struct('EnableAnimation',true,'ExecuteInitStep',true,'WarningOnUninitializedData',true,'AnimationDelay',0,'EventQueueSize',20,'MATLABTimer',true,'ClockSpeedFactor',1)...
                ,'TimerEventVars',struct('SFlogic_Initialize_after_x_5_', false, 'SFlogic_Operate_Preparation_after_x_3_', false)...
                ,'InputEventVars',struct('COIN', false, 'COFFEE', false, 'TEA', false, 'CHOCO', false, 'GINSENG', false, 'TAKEN', false)...
                ,'HistoryJunctionVars',struct()...
                ,'IsActiveVars',struct('IsActiveVar_SFlogic', false)...
                ,'ActiveChildVars',struct('ActiveChildVar_SFlogic', -1, 'ActiveChildVar_Operate', -1)...
                ,'InputEventCounters',struct()...
                ,'StepCounters',struct('SFlogic', 0)...
                ,'TimeCounters',struct('Initialize_1', 0, 'Operate_Preparation_1', 0)...
                ,'CountCounters',struct()...
                ,'HasChangedStartValues',struct()...
                ,'HasChangedPreviousValues',struct()...
                );
        end
    end

    methods (Access=public, Hidden=true)
        function fTimerCallbackImpl(this, ~)
            if ~this.StateflowInternalData.ConfigurationOptions.MATLABTimer
                return;
            end
            coder.ignoreCatch();
            try
                if isempty(this.StateflowInternalData.TimerRuntime.queuedTimerEvents)
                    % non-queued timercallback
                    this.StateflowInternalData.TimerRuntime.lastExpiredTimers = this.StateflowInternalData.TimerRuntime.active;
                    this.StateflowInternalData.TimerRuntime.executingTimerCallbackStep = true;
                    this.StateflowInternalData.TimerRuntime.enableActiveEvents();
                elseif ~this.StateflowInternalData.TimerRuntime.isQueuedTimerCallbackValid
                    this.StateflowInternalData.TimerRuntime.popQueuedTimerQueue();
                    % do not execute queued timercallback if exitCount of
                    % callback is not equal to current exitCount
                    return;
                else
                    % queued valid timer callback
                    this.StateflowInternalData.TimerRuntime.enableQueuedEvents();
                    this.StateflowInternalData.TimerRuntime.popQueuedTimerQueue();
                end
                this.fStepImpl();
                this.StateflowInternalData.TimerRuntime.executingTimerCallbackStep = false;
            catch tOriginalException
                this.StateflowInternalData.TimerRuntime.executingTimerCallbackStep = false;
                this.StateflowInternalData.QueuedMethodNames = {};
                this.StateflowInternalData.QueuedMethodArguments = {};
                throw(tOriginalException);
            end
        end

        function fTimerCallback(this, ~)
            coder.ignoreCatch();
            try
                coder.ignoreCatch();
                try
                    if this.StateflowInternalData.IsExecuting
                        this.StateflowInternalData.TimerRuntime.saveCurrentExitCounts();
                        this.StateflowInternalData.SharedRuntime.pushToEventQueue(this,'fTimerCallbackImpl',{});
                        return;
                    end
                    this.StateflowInternalData.IsExecuting = true;
                    this.fTimerCallbackImpl();
                    this.StateflowInternalData.SharedRuntime.processEventQueue(this);
                    this.StateflowInternalData.IsExecuting = false;
                catch tOriginalException
                    this.StateflowInternalData.IsExecuting = false;
                    throw(tOriginalException);
                end
            catch tOriginalException_1
                if isvalid(this)
                    throw(tOriginalException_1);
                end
            end
        end

        function fStepImpl(this, varargin)
            tTranslatedException = [];
            coder.ignoreCatch();
            try
                this.StateflowInternalData.SharedRuntime.parseArguments(this, false,  nargout, varargin{:});
                this.StateflowInternalData.AnimationRuntime.notifyStartingExecution(this);
                if this.StateflowInternalData.ConfigurationOptions.MATLABTimer == false
                    this.fNonTimerBasedTemporalUpdate();
                end
                this.fUpdateHasChangedValues();
                if ~this.StateflowInternalData.IsActiveVars.IsActiveVar_SFlogic
                    this.StateflowInternalData.IsActiveVars.IsActiveVar_SFlogic = true;
                    this.SFlogic_EntryTotal();
                else
                    this.SFlogic_DuringTotal();
                end
                this.fTimerBasedAtEveryReset();
                this.fCountUpdate();
                this.StateflowInternalData.StepCounters.SFlogic = this.StateflowInternalData.StepCounters.SFlogic + 1;
            catch tOriginalException
                this.StateflowInternalData.QueuedMethodNames = {};
                this.StateflowInternalData.QueuedMethodArguments = {};
                tTranslatedException =this.StateflowInternalData.AnimationRuntime.runtimeException(tOriginalException);

            end
            this.StateflowInternalData.AnimationRuntime.notifyEndingExecution(this);
            if ~isempty(tTranslatedException)
                throw(tTranslatedException);
            end
            if this.StateflowInternalData.ConfigurationOptions.MATLABTimer
                this.StateflowInternalData.TimerRuntime.startNewTimer('opportunistic');
            end
        end

        function EventImpl_COIN(this, varargin)
            this.StateflowInternalData.InputEventVars.COIN = true;
            try
                this.fStepImpl(varargin{:});
                this.StateflowInternalData.InputEventVars.COIN = false;
            catch tOriginalException
                this.StateflowInternalData.InputEventVars.COIN = false;
                this.StateflowInternalData.QueuedMethodNames = {};
                this.StateflowInternalData.QueuedMethodArguments = {};
                throw(tOriginalException);
            end
        end

        function EventImpl_COFFEE(this, varargin)
            this.StateflowInternalData.InputEventVars.COFFEE = true;
            try
                this.fStepImpl(varargin{:});
                this.StateflowInternalData.InputEventVars.COFFEE = false;
            catch tOriginalException
                this.StateflowInternalData.InputEventVars.COFFEE = false;
                this.StateflowInternalData.QueuedMethodNames = {};
                this.StateflowInternalData.QueuedMethodArguments = {};
                throw(tOriginalException);
            end
        end

        function EventImpl_TEA(this, varargin)
            this.StateflowInternalData.InputEventVars.TEA = true;
            try
                this.fStepImpl(varargin{:});
                this.StateflowInternalData.InputEventVars.TEA = false;
            catch tOriginalException
                this.StateflowInternalData.InputEventVars.TEA = false;
                this.StateflowInternalData.QueuedMethodNames = {};
                this.StateflowInternalData.QueuedMethodArguments = {};
                throw(tOriginalException);
            end
        end

        function EventImpl_CHOCO(this, varargin)
            this.StateflowInternalData.InputEventVars.CHOCO = true;
            try
                this.fStepImpl(varargin{:});
                this.StateflowInternalData.InputEventVars.CHOCO = false;
            catch tOriginalException
                this.StateflowInternalData.InputEventVars.CHOCO = false;
                this.StateflowInternalData.QueuedMethodNames = {};
                this.StateflowInternalData.QueuedMethodArguments = {};
                throw(tOriginalException);
            end
        end

        function EventImpl_GINSENG(this, varargin)
            this.StateflowInternalData.InputEventVars.GINSENG = true;
            try
                this.fStepImpl(varargin{:});
                this.StateflowInternalData.InputEventVars.GINSENG = false;
            catch tOriginalException
                this.StateflowInternalData.InputEventVars.GINSENG = false;
                this.StateflowInternalData.QueuedMethodNames = {};
                this.StateflowInternalData.QueuedMethodArguments = {};
                throw(tOriginalException);
            end
        end

        function EventImpl_TAKEN(this, varargin)
            this.StateflowInternalData.InputEventVars.TAKEN = true;
            try
                this.fStepImpl(varargin{:});
                this.StateflowInternalData.InputEventVars.TAKEN = false;
            catch tOriginalException
                this.StateflowInternalData.InputEventVars.TAKEN = false;
                this.StateflowInternalData.QueuedMethodNames = {};
                this.StateflowInternalData.QueuedMethodArguments = {};
                throw(tOriginalException);
            end
        end
    end

    methods (Access=private, Hidden=true)
        function SFlogic_DuringInternal(this)
            switch this.StateflowInternalData.ActiveChildVars.ActiveChildVar_SFlogic
                case 27
                    %State: Idling
                    this.Idling_DuringTotal();
                case 25
                    %State: Initialize
                    this.Initialize_DuringTotal();
                case 28
                    %State: Operate
                    this.Operate_DuringTotal();
            end
        end

        function SFlogic_DuringTotal(this)
            this.SFlogic_DuringInternal();
        end

        function SFlogic_EntryInternal(this)
            tReturnValue = this.SFlogic_DefaultTransitionPath;
            if tReturnValue
                return;
            end
        end

        function SFlogic_EntryTotal(this)
            this.SFlogic_EntryInternal();
        end

        function SFlogic_ExitInternal(this)
            switch this.StateflowInternalData.ActiveChildVars.ActiveChildVar_SFlogic
                case 27
                    %State: Idling
                    this.Idling_ExitTotal();
                case 25
                    %State: Initialize
                    this.Initialize_ExitTotal();
                case 28
                    %State: Operate
                    this.Operate_ExitTotal();
            end
        end

        function SFlogic_ExitTotal(this)
            this.SFlogic_ExitInternal();
        end

        function tReturnValue = SFlogic_DefaultTransitionPath(this)
            this.Initialize_EntryTotal();
            tReturnValue = 1;
        end

        function Idling_DuringAtomic(this)

        end

        function Idling_DuringTotal(this)
            tReturnValue = this.Idling_OuterTransitionPath;
            if tReturnValue
                return;
            end
            this.Idling_DuringAtomic();
        end

        function Idling_EntryAtomic(this)
            %State SFlogic.Idling becomes active
            this.StateflowInternalData.ActiveChildVars.ActiveChildVar_SFlogic = 27;
        end

        function Idling_EntryTotal(this)
            this.Idling_EntryAtomic();
        end

        function Idling_ExitAtomic(this)
            %State SFlogic.Idling becomes inactive
            this.StateflowInternalData.ActiveChildVars.ActiveChildVar_SFlogic = 0;
        end

        function Idling_ExitTotal(this)
            this.Idling_ExitAtomic();
        end

        function tReturnValue = Idling_OuterTransitionPath(this)
            if this.StateflowInternalData.InputEventVars.COIN


                this.Idling_ExitTotal();
                this.Operate_EntryTotal();
                tReturnValue = 1;
            else
                tReturnValue = 0;
            end
        end

        function Initialize_DuringAtomic(this)

        end

        function Initialize_DuringTotal(this)
            tReturnValue = this.Initialize_OuterTransitionPath;
            if tReturnValue
                return;
            end
            this.Initialize_DuringAtomic();
        end

        function Initialize_EntryAtomic(this)
            this.StateflowInternalData.TimeCounters.Initialize_1 = this.fGetCurrentTime;
            %State SFlogic.Initialize becomes active
            this.StateflowInternalData.ActiveChildVars.ActiveChildVar_SFlogic = 25;

            this.StateflowInternalData.TimerEventVars.SFlogic_Initialize_after_x_5_ = false;
            if this.StateflowInternalData.ConfigurationOptions.MATLABTimer
                this.StateflowInternalData.TimerRuntime.addPendingTimer('SFlogic_Initialize_after_x_5_', (5), 'this.StateflowInternalData.TimerEventVars.SFlogic_Initialize_after_x_5_', -2,false,39,0,13);
            end
        end

        function Initialize_EntryTotal(this)
            this.Initialize_EntryAtomic();
        end

        function Initialize_ExitAtomic(this)
            %State SFlogic.Initialize becomes inactive
            this.StateflowInternalData.ActiveChildVars.ActiveChildVar_SFlogic = 0;
            if this.StateflowInternalData.ConfigurationOptions.MATLABTimer
                this.StateflowInternalData.TimerRuntime.removePendingTimer('SFlogic_Initialize_after_x_5_');
            end
            this.StateflowInternalData.TimerEventVars.SFlogic_Initialize_after_x_5_ = false;
        end

        function Initialize_ExitTotal(this)
            this.Initialize_ExitAtomic();
        end

        function tReturnValue = Initialize_OuterTransitionPath(this)
            if this.StateflowInternalData.TimerEventVars.SFlogic_Initialize_after_x_5_


                this.Initialize_ExitTotal();
                this.Idling_EntryTotal();
                tReturnValue = 1;
            else
                tReturnValue = 0;
            end
        end

        function Operate_DuringInternal(this)
            switch this.StateflowInternalData.ActiveChildVars.ActiveChildVar_Operate
                case 34
                    %State: Preparation
                    this.Operate_Preparation_DuringTotal();
                case 33
                    %State: Selection
                    this.Operate_Selection_DuringTotal();
                case 35
                    %State: Serving
                    this.Operate_Serving_DuringTotal();
            end
        end

        function Operate_DuringAtomic(this)

        end

        function Operate_DuringTotal(this)
            tReturnValue = this.Operate_OuterTransitionPath;
            if tReturnValue
                return;
            end
            this.Operate_DuringAtomic();
            this.Operate_DuringInternal();
        end

        function Operate_EntryInternal(this)
            tReturnValue = this.Operate_DefaultTransitionPath;
            if tReturnValue
                return;
            end
        end

        function Operate_EntryAtomic(this)
            %State SFlogic.Operate becomes active
            this.StateflowInternalData.ActiveChildVars.ActiveChildVar_SFlogic = 28;
        end

        function Operate_EntryTotal(this)
            this.Operate_EntryAtomic();
            this.Operate_EntryInternal();
        end

        function Operate_ExitInternal(this)
            switch this.StateflowInternalData.ActiveChildVars.ActiveChildVar_Operate
                case 34
                    %State: Preparation
                    this.Operate_Preparation_ExitTotal();
                case 33
                    %State: Selection
                    this.Operate_Selection_ExitTotal();
                case 35
                    %State: Serving
                    this.Operate_Serving_ExitTotal();
            end
        end

        function Operate_ExitAtomic(this)
            %State SFlogic.Operate becomes inactive
            this.StateflowInternalData.ActiveChildVars.ActiveChildVar_SFlogic = 0;
        end

        function Operate_ExitTotal(this)
            this.Operate_ExitInternal();
            this.Operate_ExitAtomic();
        end

        function tReturnValue = Operate_DefaultTransitionPath(this)
            this.Operate_Selection_EntryTotal();
            tReturnValue = 1;
        end

        function tReturnValue = Operate_OuterTransitionPath(this)
            if this.StateflowInternalData.InputEventVars.TAKEN


                this.Operate_ExitTotal();
                this.Idling_EntryTotal();
                tReturnValue = 1;
            else
                tReturnValue = 0;
            end
        end

        function Operate_Preparation_DuringAtomic(this)

        end

        function Operate_Preparation_DuringTotal(this)
            tReturnValue = this.Operate_Preparation_OuterTransitionPath;
            if tReturnValue
                return;
            end
            this.Operate_Preparation_DuringAtomic();
        end

        function Operate_Preparation_EntryAtomic(this)
            this.StateflowInternalData.TimeCounters.Operate_Preparation_1 = this.fGetCurrentTime;
            %State SFlogic.Operate.Preparation becomes active
            this.StateflowInternalData.ActiveChildVars.ActiveChildVar_Operate = 34;

            this.StateflowInternalData.TimerEventVars.SFlogic_Operate_Preparation_after_x_3_ = false;
            if this.StateflowInternalData.ConfigurationOptions.MATLABTimer
                this.StateflowInternalData.TimerRuntime.addPendingTimer('SFlogic_Operate_Preparation_after_x_3_', (3), 'this.StateflowInternalData.TimerEventVars.SFlogic_Operate_Preparation_after_x_3_', -2,false,36,0,12);
            end
        end

        function Operate_Preparation_EntryTotal(this)
            this.Operate_Preparation_EntryAtomic();
        end

        function Operate_Preparation_ExitAtomic(this)
            %State SFlogic.Operate.Preparation becomes inactive
            this.StateflowInternalData.ActiveChildVars.ActiveChildVar_Operate = 0;
            if this.StateflowInternalData.ConfigurationOptions.MATLABTimer
                this.StateflowInternalData.TimerRuntime.removePendingTimer('SFlogic_Operate_Preparation_after_x_3_');
            end
            this.StateflowInternalData.TimerEventVars.SFlogic_Operate_Preparation_after_x_3_ = false;
        end

        function Operate_Preparation_ExitTotal(this)
            this.Operate_Preparation_ExitAtomic();
        end

        function tReturnValue = Operate_Preparation_OuterTransitionPath(this)
            if this.StateflowInternalData.TimerEventVars.SFlogic_Operate_Preparation_after_x_3_


                this.Operate_Preparation_ExitTotal();
                this.Operate_Serving_EntryTotal();
                tReturnValue = 1;
            else
                tReturnValue = 0;
            end
        end

        function Operate_Selection_DuringAtomic(this)

        end

        function Operate_Selection_DuringTotal(this)
            tReturnValue = this.Operate_Selection_OuterTransitionPath;
            if tReturnValue
                return;
            end
            this.Operate_Selection_DuringAtomic();
        end

        function Operate_Selection_EntryAtomic(this)
            %State SFlogic.Operate.Selection becomes active
            this.StateflowInternalData.ActiveChildVars.ActiveChildVar_Operate = 33;
        end

        function Operate_Selection_EntryTotal(this)
            this.Operate_Selection_EntryAtomic();
        end

        function Operate_Selection_ExitAtomic(this)
            %State SFlogic.Operate.Selection becomes inactive
            this.StateflowInternalData.ActiveChildVars.ActiveChildVar_Operate = 0;
        end

        function Operate_Selection_ExitTotal(this)
            this.Operate_Selection_ExitAtomic();
        end

        function tReturnValue = Operate_Selection_OuterTransitionPath(this)
            if this.StateflowInternalData.InputEventVars.COFFEE


                this.Operate_Selection_ExitTotal();
                this.Operate_Preparation_EntryTotal();
                tReturnValue = 1;
            else
                tReturnValue = 0;
            end
        end

        function Operate_Serving_DuringAtomic(this)

        end

        function Operate_Serving_DuringTotal(this)
            this.Operate_Serving_DuringAtomic();
        end

        function Operate_Serving_EntryAtomic(this)
            %State SFlogic.Operate.Serving becomes active
            this.StateflowInternalData.ActiveChildVars.ActiveChildVar_Operate = 35;
        end

        function Operate_Serving_EntryTotal(this)
            this.Operate_Serving_EntryAtomic();
        end

        function Operate_Serving_ExitAtomic(this)
            %State SFlogic.Operate.Serving becomes inactive
            this.StateflowInternalData.ActiveChildVars.ActiveChildVar_Operate = 0;
        end

        function Operate_Serving_ExitTotal(this)
            this.Operate_Serving_ExitAtomic();
        end

        function fInitializeChartData(this, varargin)
            tFunctionLocalVariable = [];
            if ~isempty(coder.target)
                coder.internal.errorIf(~all(tFunctionLocalVariable), 'MATLAB:sfx:MATLABCoderErrorAllDataNotInitialized', this.StateflowInternalConstData.ChartName, this.StateflowInternalConstData.UninitializedDataLinks);
            end
        end

        function fUpdateHasChangedValues(this)

        end

        function fCountUpdate(this)

        end

        function fNonTimerBasedTemporalUpdate(this)
            if ((this.fGetCurrentTime - this.StateflowInternalData.TimeCounters.Initialize_1)* this.StateflowInternalData.ConfigurationOptions.ClockSpeedFactor) >=(5)
                this.StateflowInternalData.TimerEventVars.SFlogic_Initialize_after_x_5_ = true;
            end
            if ((this.fGetCurrentTime - this.StateflowInternalData.TimeCounters.Operate_Preparation_1)* this.StateflowInternalData.ConfigurationOptions.ClockSpeedFactor) >=(3)
                this.StateflowInternalData.TimerEventVars.SFlogic_Operate_Preparation_after_x_3_ = true;
            end
        end

        function fTimerBasedAtEveryReset(this)

        end

        function tReturnValue = fGetCurrentTime(this)
            tReturnValue = this.StateflowInternalData.SharedRuntime.getPOSIXTime(this);
        end
    end
end
%#ok<*MANU>
